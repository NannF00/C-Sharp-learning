# Serialization and deserialization

# 目的

1、以某种存储形式使自定义对象持久化；

2、将对象从一个地方传递到另一个地方。

3、使程序更具维护性。

# 技术

* 二进制序列化保持类型保真度，这对于在应用程序的不同调用之间保留对象的状态很有用。例如，通过将对象序列化到剪贴板，可在不同的应用程序之间共享对象。您可以将对象序列化到流、磁盘、内存和网络等等。远程处理使用序列化“通过值”在计算机或应用程序域之间传递对象。

* XML 序列化仅序列化公共属性和字段，且不保持类型保真度。当您要提供或使用数据而不限制使用该数据的应用程序时，这一点是很有用的。由于 XML 是一个开放式标准，因此，对于通过 Web 共享数据而言，这是一个很好的选择。SOAP 同样是一个开放式标准，这使它也成为一个颇具吸引力的选择。

      using System;
      using System.Windows.Forms;
      using System.IO;
      using System.Runtime.Serialization.Formatters.Binary;//二进制序列化
      using System.Runtime.Serialization.Formatters.Soap;//SOAP序列化
      using System.Xml.Serialization;//XML序列化
      namespace WindowsFormsApplication1
      {
          public partial class Form1 : Form
          {
              public Form1()
              {
                  InitializeComponent();
              }
              //如果要想保存某个class中的字段,必须在class前面加个这样[Serializable]
              [Serializable]
              public class Person
              {
                  public int age;
                  public string name;
                  [NonSerialized] //如果某个字段不想被保存,则加个这样的标志
                  public string secret;
              }
              //序列化
              private void btnXlh_Click(object sender, EventArgs e)
              {
                  Person person = new Person();
                  person.age = 28;
                  person.name = "Hoam\r\n";
                  person.secret = "no look";
                  string str = System.AppDomain.CurrentDomain.BaseDirectory;
                  //二进制序列化
                  FileStream streamHx = new FileStream(str+"personHx.txt", FileMode.Create);
                  BinaryFormatter bFormatHx = new BinaryFormatter();
                  bFormatHx.Serialize(streamHx, person);
                  streamHx.Close();
                  //SOAP序列化
                  FileStream streamSoap = new FileStream(str + "personSoap.xml", FileMode.Create);
                  SoapFormatter bFormatSoap = new SoapFormatter();
                  bFormatSoap.Serialize(streamSoap, person);
                  streamSoap.Close();
                  //XML序列化  //某个字段加[NonSerialized]标志不起作用，仍被保存
                  FileStream streamXml = new FileStream(str+ "personXml.xml", FileMode.Create);
                  XmlSerializer xmlserilize = new XmlSerializer(typeof(Person));
                  xmlserilize.Serialize(streamXml, person);
                  streamXml.Close();
              }
              //反序列化
              private void btnFxlh_Click(object sender, EventArgs e)
              {
                  Person person = new Person();
                  string str = System.AppDomain.CurrentDomain.BaseDirectory;
                  object data;
                  //二进制反序列化
                  FileStream streamHx = new FileStream(str + "personHx.txt", FileMode.OpenOrCreate);
                  BinaryFormatter bFormatHx = new BinaryFormatter();
                  data = bFormatHx.Deserialize(streamHx); //反序列化得到的是一个object对象.须做下类型转换
                  streamHx.Close();
                  //SOAP反序列化
                  FileStream streamSoap = new FileStream(str + "personSoap.xml", FileMode.OpenOrCreate);
                  SoapFormatter bFormatSoap = new SoapFormatter();
                  data = bFormatSoap.Deserialize(streamSoap); //反序列化得到的是一个object对象.须做下类型转换
                  streamSoap.Close();
                  //XML反序列化 
                  FileStream streamXml = new FileStream(str + "personXml.xml", FileMode.OpenOrCreate);
                  XmlSerializer xmlserilize = new XmlSerializer(typeof(Person));
                  data = xmlserilize.Deserialize(streamXml); //反序列化得到的是一个object对象.须做下类型转换
                  streamXml.Close();
              }
          }
      }
